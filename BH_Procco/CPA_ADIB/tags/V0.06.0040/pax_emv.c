#include <posapi.h> // use PAXPayPro2010's path, but don't copy to project folder.

#include "debug.h"

#include "emvlib.h"
#include "appLib.h"

#include "os_define.h"
#include "OS_TYPES.h"
#include "os_interface.h"
#include "defines.h"
#include "struct.h"
#include "message.h"
#include "function.h"
#include "globlePara.h"

#ifdef DEVELOP_VERSION
// VISA 512 bits Test Key 90
EMV_CAPK capk_visa_t90={{0xA0,0x00,0x00,0x00,0x03},0x90,
0x01,0x01,64,
{0xC2,0x6B,0x3C,0xB3,0x83,0x3E,0x42,0xD8,0x27,0x0D,0xC1,0x0C,0x89,0x99,0xB2,0xDA,
0x18,0x10,0x68,0x38,0x65,0x0D,0xA0,0xDB,0xF1,0x54,0xEF,0xD5,0x11,0x00,0xAD,0x14,
0x47,0x41,0xB2,0xA8,0x7D,0x68,0x81,0xF8,0x63,0x0E,0x33,0x48,0xDE,0xA3,0xF7,0x80,
0x38,0xE9,0xB2,0x1A,0x69,0x7E,0xB2,0xA6,0x71,0x6D,0x32,0xCB,0xF2,0x60,0x86,0xF1},
1,{0x03},{0x15,0x12,0x31},
{0xB3,0xAE,0x2B,0xC3,0xCA,0xFC,0x05,0xEE,0xEF,0xAA,0x46,0xA2,0xA4,0x7E,0xD5,0x1D,
0xE6,0x79,0xF8,0x23}
};
// VISA 1408 bits Test Key 92
EMV_CAPK capk_visa_t92={{0xA0,0x00,0x00,0x00,0x03},0x92,
0x01,0x01,176,
{0x99,0x6A,0xF5,0x6F,0x56,0x91,0x87,0xD0,0x92,0x93,0xC1,0x48,0x10,0x45,0x0E,0xD8,
 0xEE,0x33,0x57,0x39,0x7B,0x18,0xA2,0x45,0x8E,0xFA,0xA9,0x2D,0xA3,0xB6,0xDF,0x65,
 0x14,0xEC,0x06,0x01,0x95,0x31,0x8F,0xD4,0x3B,0xE9,0xB8,0xF0,0xCC,0x66,0x9E,0x3F,
 0x84,0x40,0x57,0xCB,0xDD,0xF8,0xBD,0xA1,0x91,0xBB,0x64,0x47,0x3B,0xC8,0xDC,0x9A,
 0x73,0x0D,0xB8,0xF6,0xB4,0xED,0xE3,0x92,0x41,0x86,0xFF,0xD9,0xB8,0xC7,0x73,0x57,
 0x89,0xC2,0x3A,0x36,0xBA,0x0B,0x8A,0xF6,0x53,0x72,0xEB,0x57,0xEA,0x5D,0x89,0xE7,
 0xD1,0x4E,0x9C,0x7B,0x6B,0x55,0x74,0x60,0xF1,0x08,0x85,0xDA,0x16,0xAC,0x92,0x3F,
 0x15,0xAF,0x37,0x58,0xF0,0xF0,0x3E,0xBD,0x3C,0x5C,0x2C,0x94,0x9C,0xBA,0x30,0x6D,
 0xB4,0x4E,0x6A,0x2C,0x07,0x6C,0x5F,0x67,0xE2,0x81,0xD7,0xEF,0x56,0x78,0x5D,0xC4,
 0xD7,0x59,0x45,0xE4,0x91,0xF0,0x19,0x18,0x80,0x0A,0x9E,0x2D,0xC6,0x6F,0x60,0x08,
 0x05,0x66,0xCE,0x0D,0xAF,0x8D,0x17,0xEA,0xD4,0x6A,0xD8,0xE3,0x0A,0x24,0x7C,0x9F},
1,{0x03},{0x15,0x12,0x31},
{0x42,0x9C,0x95,0x4A,0x38,0x59,0xCE,0xF9,0x12,0x95,0xF6,0x63,0xC9,0x63,0xE5,0x82,0xED,
0x6E,0xB2,0x53}
};
// VISA 1984 bits Test Key 94 20080328
EMV_CAPK capk_visa_t94={{0xA0,0x00,0x00,0x00,0x03},0x94,
0x01,0x01,248,
{0xAC,0xD2,0xB1,0x23,0x02,0xEE,0x64,0x4F,0x3F,0x83,0x5A,0xBD,0x1F,0xC7,0xA6,0xF6,
 0x2C,0xCE,0x48,0xFF,0xEC,0x62,0x2A,0xA8,0xEF,0x06,0x2B,0xEF,0x6F,0xB8,0xBA,0x8B,
 0xC6,0x8B,0xBF,0x6A,0xB5,0x87,0x0E,0xED,0x57,0x9B,0xC3,0x97,0x3E,0x12,0x13,0x03,
 0xD3,0x48,0x41,0xA7,0x96,0xD6,0xDC,0xBC,0x41,0xDB,0xF9,0xE5,0x2C,0x46,0x09,0x79,
 0x5C,0x0C,0xCF,0x7E,0xE8,0x6F,0xA1,0xD5,0xCB,0x04,0x10,0x71,0xED,0x2C,0x51,0xD2,
 0x20,0x2F,0x63,0xF1,0x15,0x6C,0x58,0xA9,0x2D,0x38,0xBC,0x60,0xBD,0xF4,0x24,0xE1,
 0x77,0x6E,0x2B,0xC9,0x64,0x80,0x78,0xA0,0x3B,0x36,0xFB,0x55,0x43,0x75,0xFC,0x53,
 0xD5,0x7C,0x73,0xF5,0x16,0x0E,0xA5,0x9F,0x3A,0xFC,0x53,0x98,0xEC,0x7B,0x67,0x75,
 0x8D,0x65,0xC9,0xBF,0xF7,0x82,0x8B,0x6B,0x82,0xD4,0xBE,0x12,0x4A,0x41,0x6A,0xB7,
 0x30,0x19,0x14,0x31,0x1E,0xA4,0x62,0xC1,0x9F,0x77,0x1F,0x31,0xB3,0xB5,0x73,0x36,
 0x00,0x0D,0xFF,0x73,0x2D,0x3B,0x83,0xDE,0x07,0x05,0x2D,0x73,0x03,0x54,0xD2,0x97,
 0xBE,0xC7,0x28,0x71,0xDC,0xCF,0x0E,0x19,0x3F,0x17,0x1A,0xBA,0x27,0xEE,0x46,0x4C,
 0x6A,0x97,0x69,0x09,0x43,0xD5,0x9B,0xDA,0xBB,0x2A,0x27,0xEB,0x71,0xCE,0xEB,0xDA,
 0xFA,0x11,0x76,0x04,0x64,0x78,0xFD,0x62,0xFE,0xC4,0x52,0xD5,0xCA,0x39,0x32,0x96,
 0x53,0x0A,0xA3,0xF4,0x19,0x27,0xAD,0xFE,0x43,0x4A,0x2D,0xF2,0xAE,0x30,0x54,0xF8,
 0x84,0x06,0x57,0xA2,0x6E,0x0F,0xC6,0x17},
1,{0x03},{0x15,0x12,0x31},
{0xC4,0xA3,0xC4,0x3C,0xCF,0x87,0x32,0x7D,0x13,0x6B,0x80,0x41,0x60,0xE4,0x7D,0x43,
0xB6,0x0E,0x6E,0x0F}
};
// VISA 1152 bits Test Key 95
EMV_CAPK capk_visa_t95={{0xA0,0x00,0x00,0x00,0x03},0x95,
0x01,0x01,144,
{0xBE,0x9E,0x1F,0xA5,0xE9,0xA8,0x03,0x85,0x29,0x99,0xC4,0xAB,0x43,0x2D,0xB2,0x86,
0x00,0xDC,0xD9,0xDA,0xB7,0x6D,0xFA,0xAA,0x47,0x35,0x5A,0x0F,0xE3,0x7B,0x15,0x08,
0xAC,0x6B,0xF3,0x88,0x60,0xD3,0xC6,0xC2,0xE5,0xB1,0x2A,0x3C,0xAA,0xF2,0xA7,0x00,
0x5A,0x72,0x41,0xEB,0xAA,0x77,0x71,0x11,0x2C,0x74,0xCF,0x9A,0x06,0x34,0x65,0x2F,
0xBC,0xA0,0xE5,0x98,0x0C,0x54,0xA6,0x47,0x61,0xEA,0x10,0x1A,0x11,0x4E,0x0F,0x0B,
0x55,0x72,0xAD,0xD5,0x7D,0x01,0x0B,0x7C,0x9C,0x88,0x7E,0x10,0x4C,0xA4,0xEE,0x12,
0x72,0xDA,0x66,0xD9,0x97,0xB9,0xA9,0x0B,0x5A,0x6D,0x62,0x4A,0xB6,0xC5,0x7E,0x73,
0xC8,0xF9,0x19,0x00,0x0E,0xB5,0xF6,0x84,0x89,0x8E,0xF8,0xC3,0xDB,0xEF,0xB3,0x30,
0xC6,0x26,0x60,0xBE,0xD8,0x8E,0xA7,0x8E,0x90,0x9A,0xFF,0x05,0xF6,0xDA,0x62,0x7B},
1,{0x03},{0x15,0x12,0x31},
{0xEE,0x15,0x11,0xCE,0xC7,0x10,0x20,0xA9,0xB9,0x04,0x43,0xB3,0x7B,0x1D,0x5F,0x6E,
0x70,0x30,0x30,0xF6}
};
// VISA 1024 bits Test Key 96
EMV_CAPK capk_visa_t96={{0xA0,0x00,0x00,0x00,0x03},0x96,
0x01,0x01,128,
{0xB7,0x45,0x86,0xD1,0x9A,0x20,0x7B,0xE6,0x62,0x7C,0x5B,0x0A,0xAF,0xBC,0x44,0xA2,
0xEC,0xF5,0xA2,0x94,0x2D,0x3A,0x26,0xCE,0x19,0xC4,0xFF,0xAE,0xEE,0x92,0x05,0x21,
0x86,0x89,0x22,0xE8,0x93,0xE7,0x83,0x82,0x25,0xA3,0x94,0x7A,0x26,0x14,0x79,0x6F,
0xB2,0xC0,0x62,0x8C,0xE8,0xC1,0x1E,0x38,0x25,0xA5,0x6D,0x3B,0x1B,0xBA,0xEF,0x78,
0x3A,0x5C,0x6A,0x81,0xF3,0x6F,0x86,0x25,0x39,0x51,0x26,0xFA,0x98,0x3C,0x52,0x16,
0xD3,0x16,0x6D,0x48,0xAC,0xDE,0x8A,0x43,0x12,0x12,0xFF,0x76,0x3A,0x7F,0x79,0xD9,
0xED,0xB7,0xFE,0xD7,0x6B,0x48,0x5D,0xE4,0x5B,0xEB,0x82,0x9A,0x3D,0x47,0x30,0x84,
0x8A,0x36,0x6D,0x33,0x24,0xC3,0x02,0x70,0x32,0xFF,0x8D,0x16,0xA1,0xE4,0x4D,0x8D},
1,{0x03},{0x15,0x12,0x31},
{0x76,0x16,0xE9,0xAC,0x8B,0xE0,0x14,0xAF,0x88,0xCA,0x11,0xA8,0xFB,0x17,0x96,0x7B,
0x73,0x94,0x03,0x0E}
};
// VISA 768 bits Test Key 97
EMV_CAPK capk_visa_t97={{0xA0,0x00,0x00,0x00,0x03},0x97,
0x01,0x01,96,
{0xAF,0x07,0x54,0xEA,0xED,0x97,0x70,0x43,0xAB,0x6F,0x41,0xD6,0x31,0x2A,0xB1,0xE2,
0x2A,0x68,0x09,0x17,0x5B,0xEB,0x28,0xE7,0x0D,0x5F,0x99,0xB2,0xDF,0x18,0xCA,0xE7,
0x35,0x19,0x34,0x1B,0xBB,0xD3,0x27,0xD0,0xB8,0xBE,0x9D,0x4D,0x0E,0x15,0xF0,0x7D,
0x36,0xEA,0x3E,0x3A,0x05,0xC8,0x92,0xF5,0xB1,0x9A,0x3E,0x9D,0x34,0x13,0xB0,0xD9,
0x7E,0x7A,0xD1,0x0A,0x5F,0x5D,0xE8,0xE3,0x88,0x60,0xC0,0xAD,0x00,0x4B,0x1E,0x06,
0xF4,0x04,0x0C,0x29,0x5A,0xCB,0x45,0x7A,0x78,0x85,0x51,0xB6,0x12,0x7C,0x0B,0x29},
1,{0x03},{0x15,0x12,0x31},
{0x80,0x01,0xCA,0x76,0xC1,0x20,0x39,0x55,0xE2,0xC6,0x28,0x41,0xCD,0x6F,0x20,0x10,
0x87,0xE5,0x64,0xBF}
};
// VISA 896 bits Test Key 98
EMV_CAPK capk_visa_t98={{0xA0,0x00,0x00,0x00,0x03},0x98,
0x01,0x01,112,
{0xCA,0x02,0x6E,0x52,0xA6,0x95,0xE7,0x2B,0xD3,0x0A,0xF9,0x28,0x19,0x6E,0xED,0xC9,
0xFA,0xF4,0xA6,0x19,0xF2,0x49,0x2E,0x3F,0xB3,0x11,0x69,0x78,0x9C,0x27,0x6F,0xFB,
0xB7,0xD4,0x31,0x16,0x64,0x7B,0xA9,0xE0,0xD1,0x06,0xA3,0x54,0x2E,0x39,0x65,0x29,
0x2C,0xF7,0x78,0x23,0xDD,0x34,0xCA,0x8E,0xEC,0x7D,0xE3,0x67,0xE0,0x80,0x70,0x89,
0x50,0x77,0xC7,0xEF,0xAD,0x93,0x99,0x24,0xCB,0x18,0x70,0x67,0xDB,0xF9,0x2C,0xB1,
0xE7,0x85,0x91,0x7B,0xD3,0x8B,0xAC,0xE0,0xC1,0x94,0xCA,0x12,0xDF,0x0C,0xE5,0xB7,
0xA5,0x02,0x75,0xAC,0x61,0xBE,0x7C,0x3B,0x43,0x68,0x87,0xCA,0x98,0xC9,0xFD,0x39},
1,{0x03},{0x15,0x12,0x31},
{0xE7,0xAC,0x9A,0xA8,0xEE,0xD1,0xB5,0xFF,0x1B,0xD5,0x32,0xCF,0x14,0x89,0xA3,0xE5,
0x55,0x75,0x72,0xC1}
};
// VISA 1024 bits Test Key 99
EMV_CAPK capk_visa_t99={{0xA0,0x00,0x00,0x00,0x03},0x99,
0x01,0x01,128,
{0xAB,0x79,0xFC,0xC9,0x52,0x08,0x96,0x96,0x7E,0x77,0x6E,0x64,0x44,0x4E,0x5D,0xCD,
0xD6,0xE1,0x36,0x11,0x87,0x4F,0x39,0x85,0x72,0x25,0x20,0x42,0x52,0x95,0xEE,0xA4,
0xBD,0x0C,0x27,0x81,0xDE,0x7F,0x31,0xCD,0x3D,0x04,0x1F,0x56,0x5F,0x74,0x73,0x06,
0xEE,0xD6,0x29,0x54,0xB1,0x7E,0xDA,0xBA,0x3A,0x6C,0x5B,0x85,0xA1,0xDE,0x1B,0xEB,
0x9A,0x34,0x14,0x1A,0xF3,0x8F,0xCF,0x82,0x79,0xC9,0xDE,0xA0,0xD5,0xA6,0x71,0x0D,
0x08,0xDB,0x41,0x24,0xF0,0x41,0x94,0x55,0x87,0xE2,0x03,0x59,0xBA,0xB4,0x7B,0x75,
0x75,0xAD,0x94,0x26,0x2D,0x4B,0x25,0xF2,0x64,0xAF,0x33,0xDE,0xDC,0xF2,0x8E,0x09,
0x61,0x5E,0x93,0x7D,0xE3,0x2E,0xDC,0x03,0xC5,0x44,0x45,0xFE,0x7E,0x38,0x27,0x77},
1,{0x03},{0x15,0x12,0x31},
{0x4A,0xBF,0xFD,0x6B,0x1C,0x51,0x21,0x2D,0x05,0x55,0x2E,0x43,0x1C,0x5B,0x17,0x00,
0x7D,0x2F,0x5E,0x6D}
};
void AddAllVSDCtestKeys(void)
{
    int iRet;

    iRet = EMVAddCAPK(&capk_visa_t90);
    iRet = EMVAddCAPK(&capk_visa_t92);
    iRet = EMVAddCAPK(&capk_visa_t94);
    iRet = EMVAddCAPK(&capk_visa_t95);
    iRet = EMVAddCAPK(&capk_visa_t96);
    iRet = EMVAddCAPK(&capk_visa_t98);
    iRet = EMVAddCAPK(&capk_visa_t99);
}
#endif




extern void Get_EMV_tags(void);




// If there's only one applet, this function will not be called.
int cEMVWaitAppSel(int TryCnt, EMV_APPLIST List[], int AppNum)
{
    return EMV_OK;
}

// Callback function required by EMV core.
// developer customize
int cEMVInputAmount(ulong *AuthAmt, ulong *CashBackAmt)
{
	uchar	szTotalAmt[20];

	if( gPTStruct.TotalAmount[0]!=0 )
	{
        sprintf(szTotalAmt, "%.12s", gPTStruct.TotalAmount);
		*AuthAmt = atol((char *)szTotalAmt);
		if( CashBackAmt!=NULL )
		{
			*CashBackAmt = 0L;
		}
	}
	else
	{
		*AuthAmt = 0L;
		if( CashBackAmt!=NULL )
		{
			*CashBackAmt = 0L;
		}
	}
	if( CashBackAmt==NULL )
	{
		// Set cash back amount
		//EMVSetTLVData(0x9F03, (uchar *)"\x00\x00\x00\x00\x00\x00", 6);
		//EMVSetTLVData(0x9F04, (uchar *)"\x00\x00\x00\x00", 4);
	}

	return EMV_OK;
}

// Callback function required by EMV core.
// When processing DOL, if there is a tag that EMV core doesn't know about, core will call this function.
// developer should offer processing for proprietary tag.
// if really unable to, just return -1
int cEMVUnknowTLVData(ushort iTag, uchar *psDat, int iDataLen)
{
    return -1;
}

// Callback function required by EMV core.
// Wait holder enter PIN.
// developer customized.
int cEMVGetHolderPwd(int iTryFlag, int iRemainCnt, uchar *pszPlainPin)
{
    // online PIN processing
	if( pszPlainPin==NULL )
	{
	}


	// Offline plain/enciphered PIN processing below
	//add by chens 2014.04.23 for Account Maintainance Function
	if( iRemainCnt==0 && memcmp(gPTStruct.TransType,TYPE_73,2)==0)
		return EMV_NO_PASSWORD;
	
	ScrClrLine(2, 7);
	if( iRemainCnt==1 )
	{
		PubDispString("LAST ENTER PIN", 4|DISP_LINE_LEFT);
        PubBeepErr();
		DelayMs(1500);
	}

	ScrClrLine(2, 7);
	if( iTryFlag!=0 )
	{
		PubDispString("PIN ERR, RETRY", 2|DISP_LINE_LEFT);
	}

	if (gLanguage == ARABIC)
	{
		ScrCls();
		ArShowString(0, SHIFT_CENTER, "ÃÏÎá ÑÞã ÇáÊÚÑíÝ ");
		ArShowString(2, SHIFT_CENTER, "ÇáÔÎÕí ÇáÎÇÕ Èß ");
	}
	else
	{
		//PubDispString("ENTER I.F.C PIN", 4|DISP_LINE_LEFT);//PLS ENTER PIN
	//	PubDispString("ENTER I.F.C PIN", 4|DISP_LINE_LEFT);//PLS ENTER PIN
		PubDispString("ENTER INSTANT", 0|DISP_LINE_LEFT);//PLS ENTER PIN
		PubDispString("FINANCE", 2|DISP_LINE_LEFT);
		PubDispString("CARDHOLDER PIN", 4|DISP_LINE_LEFT);
//		getkey();
	}


	if (pszPlainPin==NULL)
	{
		return EMV_OK;
	}

	if (1)  // S80
	{
		// Offline PIN, done by core itself since EMV core V25_T1. Application only needs to display prompt message.
        // In this mode, cEMVGetHolderPwd() will be called twice. the first time is to display message to user,
        // then back to kernel and wait PIN. afterwards kernel call this again and inform the process result.
        if (pszPlainPin[0]==EMV_PED_TIMEOUT)
        {
            // EMV core has processed PIN entry and it's timeout
        	ScrClrLine(2, 7);
            PubDispString("TIME OUT", 6|DISP_LINE_LEFT);
            PubBeepErr();
            PubWaitKey(3);
            return EMV_TIME_OUT;
        }
        else if (pszPlainPin[0]==EMV_PED_WAIT)
        {
            // API is called too frequently
            DelayMs(1000);
        	ScrClrLine(2, 7);
            ScrGotoxy(32, 6);
	    	return EMV_OK;
        }
        else if (pszPlainPin[0]==EMV_PED_FAIL)
        {
            // EMV core has processed PIN entry and PED failed.
        	ScrClrLine(2, 7);
            PubDispString("PED ERROR", 6|DISP_LINE_LEFT);
            PubBeepErr();
            PubWaitKey(3);
            return EMV_NO_PINPAD;
        }
        else
        {
            // EMV PIN not processed yet. So just display.
            ScrGotoxy(32, 6);
	    	return EMV_OK;
        }
	}
}

// Callback function required by EMV core.
// Voice referral.
// If not support, return REFER_DENIAL.
int cEMVReferProc(void)
{
	return REFER_DENIAL;
}

// Callback function required by EMV core.
// TC advise after EMV transaction. If not support, immediately return.
void cEMVAdviceProc(void)
{
}

//Áª»ú´¦Àí
/*
	´¦Àí²½Öè£º
	(1)²¦ºÅÁ¬½ÓÖ÷»ú,Èç¹ûËùÓÐ½»Ò×¶¼ÒªÁª»ú£¬ÄÇÃ´¿ÉÒÔÔÚ²åÈëIC¿¨Ê±Ô¤²¦ºÅ,
	   Èç¹û²¦ºÅÊ§°Ü·µ»ØONLINE_FAILED
	(2)Í¨¹ýº¯ÊýEMVGetTLVData()»ñµÃ½»Ò×Êý¾Ý°üÐèÒªµÄÊý¾Ý£¬²¢´ò°ü¡£
	(3)±£´æ³åÕýÊý¾Ý¼°±êÖ¾,È»ºó·¢ËÍ½»Ò×Êý¾Ý°üµ½Ö÷»ú(³åÕý´¦ÀíÍêÈ«ÓÉÓ¦ÓÃÍê³É)
	(4)½ÓÊÕÖ÷»úµÄ»ØÓ¦Êý¾Ý°ü,¸ù¾ÝÖ÷»úµÄ»ØÓ¦£¬×öÈçÏÂ·µ»Ø£º
	   A.Èç¹ûÖ÷»ú·µ»ØÅú×¼£¬Ôò¸ù¾Ý·µ»ØÊý¾ÝÌîÐ´RspCode¡¢AuthCode¡¢AuthCodeLenµÈ
		 ²ÎÊýµÄÖµ£¬²¢·µ»ØONLINE_APPROVE
	   B.Èç¹ûÖ÷»ú¾Ü¾ø½»Ò×,Ôò¸ù¾Ý·µ»ØÊý¾ÝÌîÐ´RspCode,Èç¹ûÆäËû²ÎÊýÒ²ÓÐÊý¾ÝÖµ£¬
		 Í¬ÑùÐèÒªÌîÐ´£¬·µ»ØONLINE_DENIAL
	   C.Èç¹ûÖ÷»úÇëÇóÓïÒô²Î¿¼,Ôò¸ù¾Ý·µ»ØÊý¾ÝÌîÐ´RspCode,Èç¹ûÆäËû²ÎÊýÒ²ÓÐÊý¾ÝÖµ£¬
		 Í¬ÑùÐèÒªÌîÐ´£¬·µ»ØONLINE_REFER¡£ÐèÒªËµÃ÷µÄÊÇ£ººÜ¶àÇé¿ö¿ÉÄÜÃ»ÓÐ²Î¿¼´¦Àí£¬
		 ÔÚÕâÖÖÇé¿öÏÂ£¬Ó¦ÓÃ³ÌÐò¾Í²»ÐèÒª·µ»ØONLINE_REFERÁË

	µÈ½»Ò×´¦Àí³É¹¦ºó£¬Ó¦ÓÃ³ÌÐò²Å¿ÉÒÔÇå³ý³åÕý±êÖ¾¡£
*/
/* Online processing.
    steps:
	(1) Dial. If dial failed, return ONLINE_FAILED
	(2) Use EMVGetTLVData() to retrieve data from core, pack to ISO8583.
	(3) Save reversal data and flag, then send request to host
	(4) Receive from host, then do accordingly:
	   A. If host approved, copy RspCode,AuthCode,AuthCodeLen or so, and return ONLINE_APPROVE
	   B. If host denial, copy RspCode or so, return ONLINE_DENIAL
	   C. If host require voice referral, copy RspCode or so.,return ONLINE_REFER.
	       Note that if not support, needn't return ONLINE_REFER but directly ONLINE_DENIAL

	Reversal flag can only be cleared after all EMV processing, NOT immediately after online.
*/
int  cEMVOnlineProc(uchar *psRspCode,  uchar *psAuthCode, int *piAuthCodeLen,
					uchar *psAuthData, int *piAuthDataLen,
					uchar *psScript,   int *piScriptLen)
{
    WORD    usRet;

	Get_EMV_tags();
//	memcpy(ARQC, gPTStruct.AC, 8);

	//add by chens 2014.04.22
	//TR.EMVData.issuerScriptTemplateLength[0]=0;
	memset(&TR.EMVData.issuerScriptTemplateLength,0x00,sizeof(TR.EMVData.issuerScriptTemplateLength));        
////////////////////////////////////////////////////////////

#ifndef APPL_DEMO
	if (memcmp(gPTStruct.TransType,TYPE_70,2)==0)
	{
		gHostType=AUTH_HOST;
		PrepareField55(OS_FALSE,OS_TRUE);	// ????
		usRet = ISO_SendReceive(OS_TRUE, ISO_RETAIL);
		if (usRet!=STAT_OK)
		{
			Comms_Disconnect();
			return ONLINE_FAILED;
		}

		// Removed by Kim_LinHB 2014-5-22 incorrect steps
		// print a lot of receipts
	}
    else if (memcmp(gPTStruct.TransType,TYPE_72,2)==0)
    {
		gHostType=AUTH_HOST;
		PrepareField55(OS_FALSE,OS_TRUE);	// ????
		usRet = ISO_SendReceive(OS_TRUE, ISO_PAYMENT);
		if (usRet!=STAT_OK)
		{
			Comms_Disconnect();
			return ONLINE_FAILED;
		}
    }

	//add by chens 2014.04.21
    else if (memcmp(gPTStruct.TransType,TYPE_73,2)==0)
    {

		gHostType=AUTH_HOST;
		PrepareField55(OS_FALSE,OS_TRUE);
		usRet = ISO_SendReceive(OS_TRUE, ISO_ACCOUNTMAINTENANCE);
		if (usRet!=STAT_OK)
		{
			Comms_Disconnect();
			return ONLINE_FAILED;
		}

		PrepareField55(OS_FALSE,OS_TRUE);
		usRet = ISO_SendReceive(OS_TRUE, ISO_ACCOUNTMAINTENANCE_ADVICE);
		if (usRet!=STAT_OK)
		{
			Comms_Disconnect();
			return ONLINE_FAILED;
		}
		
    }
	
    else
    {
        return ONLINE_FAILED;
    }
#endif

    // set response code
	memcpy(psRspCode, gPTStruct.ResponseCode, 2);
    // get response issuer data
    *piAuthDataLen = TR.EMVData.issuerAuthenticationDataLength;
    if (*piAuthDataLen)
    {
        memcpy(psAuthData, TR.EMVData.issuerAuthenticationData, TR.EMVData.issuerAuthenticationDataLength);
    }
    
	//add by chens 2014.04.22
	memcpy(psScript,  TR.EMVData.issuerScriptTemplate[0], TR.EMVData.issuerScriptTemplateLength[0]);
	memcpy(psScript+TR.EMVData.issuerScriptTemplateLength[0],  TR.EMVData.issuerScriptTemplate[1], TR.EMVData.issuerScriptTemplateLength[1]);
	*piScriptLen = TR.EMVData.issuerScriptTemplateLength[0]+TR.EMVData.issuerScriptTemplateLength[1];
	
    /*
	if( memcmp(glRecvPack.szRspCode, "00", LEN_RSP_CODE)!=0 )
	{
		return ONLINE_DENIAL;
	}*/

    Beep();
    return ONLINE_APPROVE;
}

// Callback function required by EMV core.
// Display "EMV PIN OK" info. (plaintext/enciphered PIN)
void cEMVVerifyPINOK(void)
{
	ScrClrLine(2, 7);
	PubDispString("PIN VERIFY OK", 4|DISP_LINE_LEFT);
	PubWaitKey(1);
}

// Callback function required by EMV core.
// Don't need to care about this function
int cCertVerify(void)
{
//	AppSetMckParam(!ChkIssuerOption(ISSUER_EN_EMVPIN_BYPASS));
	return -1;
}

// Callback function required by EMV core.
// in EMV ver 2.1+, this function is called before GPO
int cEMVSetParam(void)
{
	return 0;
}

int usEMVGetTLVFromColxn(WORD usTag, BYTE *psData, WORD *pLen)
{
    int iRet, iOutLen;
    
    if ((usTag%256)==0)
    {
        usTag /= 256;
    }
    iRet = EMVGetTLVData((unsigned short)usTag, psData, &iOutLen);
    if (iRet==EMV_OK)
    {
        *pLen = (WORD)iOutLen;
    }

    return iRet;
}


// end of file

